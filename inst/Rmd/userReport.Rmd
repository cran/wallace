---
title: Wallace Session `r Sys.Date()`
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
knit_engines$set(asis = function(options) {
  if (options$echo && options$eval) knit_child(text = options$code)
})
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

```{r vars, echo = FALSE, include = FALSE}
# comp1
occ <- values$mod_db
csv <- !is.null(input$userCSV)
occ.csv <- occ | csv
# comp2
remLoc <- !is.null(values$removedAll)
drawPoly <- !is.null(values$ptsSel)
thin <- input$goThin != 0
# comp3
yesPreds <- input$bcRes != ""
# comp4
backg <- !is.null(values$backgExt)
isBB <- if (backg) input$backgSel == 'bb' else FALSE
isMCP <- if (backg) input$backgSel == 'mcp' else FALSE
isUserBG <- if (backg) input$backgSel == 'user' else FALSE
# comp5
part <- input$goPart != 0
isBlock <- if (!is.null(values$partSel2)) values$partSel2 == 'block' else FALSE
isCB1 <- if (!is.null(values$partSel2)) values$partSel2 == 'cb1' else FALSE
isCB2 <- if (!is.null(values$partSel2)) values$partSel2 == 'cb2' else FALSE
isJack <- if (!is.null(values$partSel2)) values$partSel2 == 'jack' else FALSE
isRandom <- if (!is.null(values$partSel2)) values$partSel2 == 'random' else FALSE
# comp6
model <- input$goEval != 0
isBC <- if (!is.null(values$evalMods)) input$enmSel == 'BIOCLIM' else FALSE
isMX <- if (!is.null(values$evalMods)) input$enmSel == 'Maxent' else FALSE
# comp7
mapPred <- !is.null(values$goMapPred)
respCurv <- !is.null(values$respCurvParams) & isMX
bcEnvelPlot <- !is.null(values$bcEnvelPlot) & isBC
mxEvalPlot <- !is.null(values$mxEvalPlot) & isMX
isViz <- mapPred | respCurv | bcEnvelPlot | mxEvalPlot
# comp8
projArea <- !is.null(values$projMsk)
projTime <- !is.null(values$projTimeVars)
projAny <- projArea | projTime
mess <- !is.null(values$mess)
```

Please find below the R code history from your *Wallace* session. 

You can reproduce your session results by running this R Markdown file in RStudio. 

Each code block is called a "chunk", and you can run them either one-by-one or all at once by choosing an option in the "Run" menu at the top-right corner of the "Source" pane in RStudio. 

For more detailed information see <http://rmarkdown.rstudio.com>).

### Package installation

Wallace uses the following R packages that must be installed and loaded before starting.
```{r loadPkgs}
library(devtools)
library(spocc)
library(maptools)
library(spThin)
library(dismo)
library(rgeos)
library(repmis)
library(maps)
library(ENMeval)
```

Wallace also includes several functions developed to help integrate different packages and some additional functionality. For this reason, it is necessary to load the file `functions.R`, The function `system.file()` finds this script, and `source()` loads it.

```{r loadFunctions}
source(system.file('shiny/funcs', 'functions.R', package = 'wallace'))
```

## Record of analysis for *`r "{{spName}}"`*.

```{asis, echo = occ.csv, include = occ.csv}
### Obtain Occurrence Data
```

```{asis, echo = occ, include = occ}
The search for occurrences was limited to `r {{occNum}}` records. Obtain occurrence records of the selected species from the `r "{{dbName}}"` database.
```

```{r occSearch, eval = occ, echo = occ, include = occ}
results <- spocc::occ(query = "{{spName}}", from = "{{dbName}}", limit = {{occNum}}, has_coords = TRUE)
results.data <- results[["{{dbName}}"]]$data[[formatSpName("{{spName}}")]]
occs <- remDups(results.data)  # remove rows with duplicate coordinates
# make sure latitude and longitude are numeric (sometimes they aren't)
occs$latitude <- as.numeric(occs$latitude)
occs$longitude <- as.numeric(occs$longitude)
# give all records a unique ID
occs$origID <- row.names(occs)
```

```{asis, echo = csv}
User CSV path with occurrence data (change to the path of the file in your computer):
```

```{r occInput, echo = csv, eval = csv}
inFile <- read.csv("{{occsCSV}}", header = TRUE)  # load occurrence data
occs <- remDups(inFile)  # remove duplicate records
```

```{asis, echo = thin | remLoc | drawPoly, include = drawPoly}
### Process Occurrence Data
```

```{asis, echo = remLoc, eval = remLoc, include = remLoc}
Remove the occurrence localities with the following IDs: `r {{occsRemoved}}`.
```

```{r remLocs, echo = remLoc, eval = remLoc, include = remLoc}
remo <- which(occs$origID %in% {{occsRemoved}})  # find row numbers that match IDs to be removed
occs <- occs[-remo, ]  # remove the selected rows
```

```{asis, echo = drawPoly, eval = drawPoly, include = drawPoly}
You chose `r length({{occsSel}})` of `r nrow(occs)` total occurrence localities via polygon selection to keep in the analysis.
```

```{r remLocs2, echo = drawPoly, eval = drawPoly, include = drawPoly}
occs <- occs[{{occsSel}}, ]  # subset occs by selected rows
```

```{asis, echo = thin, include = thin}
Spatial thinning selected. Thin distance selected is `r {{thinDist}}` m.
```

```{r doThin, echo = thin, eval = thin, include = thin}
output <- spThin::thin(occs, 'latitude', 'longitude', 'name', thin.par = {{thinDist}}, reps = 100, locs.thinned.list.return = TRUE, write.files = FALSE, verbose = FALSE)
```

```{asis, echo = thin, include = thin}
Since spThin did 100 iterations, there are 100 different variations of how it thinned your occurrence localities. As there is a stochastic element in the algorithm, some iterations may include more localities than the others, and we need to make sure we maximize the number of localities we proceed with.
```

```{r doThin2, echo = thin, eval = thin, include = thin}
maxThin <- which(sapply(output, nrow) == max(sapply(output, nrow)))  # find the iteration that returns the max number of occurrences
maxThin <- output[[ifelse(length(maxThin) > 1, maxThin[1], maxThin)]]  # if there's more than one max, pick the first one
occs <- occs[as.numeric(rownames(maxThin)),]  # subset occs to match only thinned occs
```

```{asis, echo = yesPreds, eval = yesPreds, include = yesPreds}
### Obtain Environmental Data
Using WorldClim (http://www.worldclim.org/) bioclimatic dataset at resolution of `r {{predsRes}}` arcmin.
```

```{r getPreds, eval = yesPreds, echo = yesPreds, include = yesPreds}
preds <- raster::getData(name = "worldclim", var = "bio", res = {{predsRes}}, lat = {{bcLat}}, lon = {{bcLon}})
locs.vals <- raster::extract(preds[[1]], occs[, c('longitude', 'latitude')])  # extract environmental values at occ grid cells
occs <- occs[!is.na(locs.vals), ]  # remove occs without environmental values from inFile
```


```{r switch, include = FALSE, eval = backg}
backgSwitch <- switch("{{backgSel}}", 'bb'='Bounding Box', 'mcp'='Minimum Convex Polygon', 'user'='User-defined')
```

```{asis, echo = backg, eval = backg, include = backg}
### Process Environmental Data
Background selection technique chosen as `r backgSwitch`.
Buffer size of the study extent polygon defined as `r {{backgBuf}}` km.
```

```{r backgBuf, echo = isBB, eval = isBB, include = isBB}
xmin <- min(occs$longitude) - ({{backgBuf}} + res(preds)[1])
xmax <- max(occs$longitude) + ({{backgBuf}} + res(preds)[1])
ymin <- min(occs$latitude) - ({{backgBuf}} + res(preds)[1])
ymax <- max(occs$latitude) + ({{backgBuf}} + res(preds)[1])
bb <- matrix(c(xmin, xmin, xmax, xmax, xmin, ymin, ymax, ymax, ymin, ymin), ncol=2)
backgExt <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(bb)), 1)))
```

```{r backgBuf2, echo = isMCP, eval = isMCP, include = isMCP}
xy_mcp <- mcp(occs[,2:3])
bb <- xy_mcp@polygons[[1]]@Polygons[[1]]@coords
backgExt <- rgeos::gBuffer(xy_mcp, width = {{backgBuf}} + res(preds)[1])
```

```{asis, echo = isUserBG, eval = isUserBG, include = isUserBG}
User study extent name is `r "{{userBGname}}"`. User study extent path is `r "{{userBGpath}}"`.
```

```{r userBackgPoly, echo = isUserBG, eval = isUserBG, include = isUserBG}
shp <- read.csv("{{userBGpath}}", header = TRUE)  # read csv with coordinates for polygon
```

```{asis, echo = backg, include = backg}
Generate the user-defined study extent plus the buffer:
```

```{r userBackgPoly2, echo = isUserBG, eval = isUserBG, include = isUserBG}
shp <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(shp)), 1)))
shp <- rgeos::gBuffer(shp, width = {{backgBuf}} + res(preds)[1])
backgExt <- shp
bb <- shp@polygons[[1]]@Polygons[[1]]@coords
```

```{asis, echo = backg, include = backg}
Mask environmental variables by `r backgSwitch`, and take a random sample of background values from the study extent. As the sample is random, your results may be different than those in the session. If there seems to be too much variability in these background samples, try increasing the number from 10,000 to something higher (e.g. 50,000 or 100,000). The better your background sample, the less variability you'll have between runs.
```

```{r predsMask, echo = backg, eval = backg, include = backg}
predsBackgCrop <- raster::crop(preds, backgExt)
predsBackgMsk <- raster::mask(predsBackgCrop, backgExt)
occs.locs <- occs[,2:3]
bg.coords <- dismo::randomPoints(predsBackgMsk, 10000)  # generate 10,000 background points
bg.coords <- as.data.frame(bg.coords)  # get the matrix output into a data.frame
```

```{asis, echo = part, include = part}
### Partition Occurrence Data
Here, occurrence data is partitioned for cross-validation.
```

```{r switch2, include = FALSE, eval = part}
partSwitch <- switch("{{partSel}}", 'block'='Block', 'cb1'='Checkerboard 1', 'cb2'='Checkerboard 2', 'jack'='Jackknife', 'random'='Random')
```

```{asis, echo = part, eval = part, include = part}
Data partition by `r partSwitch` method.
```

```{r blockGrp, echo = isBlock, eval = isBlock, include = isBlock}
group.data <- ENMeval::get.block(occ=occs.locs, bg.coords=bg.coords)
```

```{r check1Grp, echo = isCB1, eval = isCB1, include = isCB1}
group.data <- ENMeval::get.checkerboard1(occ=occs.locs, env=predsBackgMsk, bg.coords=bg.coords, aggregation.factor={{aggFact}})
```

```{r check2Grp, echo = isCB2, eval = isCB2, include = isCB2}
group.data <- ENMeval::get.checkerboard2(occ=occs.locs, env=predsBackgMsk, bg.coords=bg.coords, aggregation.factor={{aggFact}})
```

```{r jackGrp, echo = isJack, eval = isJack, include = isJack}
group.data <- ENMeval::get.jackknife(occ=occs.locs, bg.coords=bg.coords)
```

```{r randGrp, echo = isRandom, eval = isRandom, include = isRandom}
group.data <- ENMeval::get.randomkfold(occ=occs.locs, bg.coords=bg.coords, kfolds={{kfoldsSel}})
```

```{asis, echo = part, include = part}
Define modeling parameters:
```

```{r params, echo = part, eval = part, include = part}
modParams <- list(occ.pts=occs.locs, bg.pts=bg.coords, occ.grp=group.data[[1]], bg.grp=group.data[[2]])
```


```{asis, echo = model, eval = model, include = model}
### Build and Evaluate Niche Model
`r "{{enmSel}}"` model selected.
```

```{r bioclim, echo = isBC, eval = isBC, include = isBC}
e <- BioClim_eval(modParams$occ.pts, modParams$bg.pts, modParams$occ.grp, modParams$bg.grp, predsBackgMsk)
evalTbl <- e$results
evalMods <- e$models
names(e$predictions) <- "Classic_BIOCLIM"
evalPreds <- e$predictions
occVals <- raster::extract(e$predictions, modParams$occ.pts)  # get predicted values for occ grid cells
mtps <- min(occVals)  # apply minimum training presence threshold
# Define 10% training presence threshold
if (length(occVals) < 10) {  # if less than 10 occ values, find 90% of total and round down
  n90 <- floor(length(occVals) * 0.9)
} else {  # if greater than or equal to 10 occ values, round up
  n90 <- ceiling(length(occVals) * 0.9)
}
p10s <- rev(sort(occVals))[n90]  # apply 10% training presence threshold
```

```{r maxent, echo = isMX, eval = isMX, results = 'hide'}
rms <- seq({{rmsSel1}}, {{rmsSel2}}, {{rmsBy}})  # define the vector of RMs to input
e <- ENMeval::ENMevaluate(modParams$occ.pts, predsBackgMsk, bg.coords=modParams$bg.pts, RMvalues=rms, fc={{fcsSel}}, method='user', occ.grp=modParams$occ.grp, bg.grp=modParams$bg.grp)
evalTbl <- e@results
evalMods <- e@models
evalPreds <- e@predictions  # raw predictions

evalPredsLog <- stack(sapply(e@models, function(x) predict(x, predsBackgMsk)))  # logistic predictions

occVals <- raster::extract(e@predictions, modParams$occ.pts)  # get predicted values for occ grid cells
mtps <- apply(occVals, MARGIN = 2, min)  # apply minimum training presence threshold over all models
# Define 10% training presence threshold
if (length(occVals) < 10) {  # if less than 10 occ values, find 90% of total and round down
  n90 <- floor(length(occVals) * 0.9)
} else {  # if greater than or equal to 10 occ values, round up
  n90 <- ceiling(length(occVals) * 0.9)
}
p10s <- apply(occVals, MARGIN = 2, function(x) rev(sort(x))[n90])  # apply 10% training presence threshold over all models
```

```{asis, echo = isViz, include = isViz}
### Visualize Niche Model
You chose to view visualizations of your modeling analysis results.
```

```{r respCurv, echo = respCurv, eval = respCurv, include = respCurv}
dismo::response(evalMods[[{{respCurvParamsMod}}]], var = "{{respCurvParamsVar}}")
```

```{r bcPlot, echo = bcEnvelPlot, eval = bcEnvelPlot, include = bcEnvelPlot}
plot(evalMods[[1]], a = {{bcPlot1}}, b = {{bcPlot2}}, p = {{bcPlotP}})
```

```{r evalPlot, echo = mxEvalPlot, eval = mxEvalPlot, include = mxEvalPlot}
ENMeval::eval.plot(evalTbl, value = "{{mxEvalPlotSel}}")
```

```{asis, echo = projAny}
### Project Niche Model
You selected to project your model. First define a polygon with the coordinates you chose, then crop and mask your predictor rasters. Finally, predict suitability values for these new raster cells based on the model you selected.
```

```{r projSel, echo = projAny, eval = projAny, include = projAny}
projCoords <- data.frame(x = {{projAreaX}}, y = {{projAreaY}})
projPoly <- sp::SpatialPolygons(list(sp::Polygons(list(sp::Polygon(projCoords)), ID=1)))

# Select your model from the evalMods list
modSel <- evalMods[[{{modSel}}]]
```

```{asis, echo = projArea}
### Project Niche Model to New Extent
Now use crop and mask the predictor variables by projPoly, and use the predict() function to predict the values for the new extent based on the model selected.
```

```{r projArea, echo = projArea, eval = projArea, include = projArea}
predsProj <- raster::crop(preds, projPoly)
predsMsk <- raster::mask(predsProj, projPoly)

newExtProj <- dismo::predict(modSel, predsMsk)
plot(newExtProj)
```

```{asis, echo = projTime}
### Project Niche Model to New Time
Now download the future climate variables chosen with *Wallace*, crop and mask them by projPoly, and use the predict() function to predict the values for the new time based on the model selected.
```

```{r projTime, echo = projTime, eval = projTime, include = projTime}
predsFuture <- raster::getData("CMIP5", var = "bio", res = {{predsRes}}, rcp = {{selRCP}}, model = "{{selGCM}}", year = {{selTime}})

predsProj <- raster::crop(predsFuture, projPoly)
predsMsk <- raster::mask(predsProj, projPoly)

# rename future climate variable names
names(predsMsk) <- names(preds)
futureProj <- dismo::predict(modSel, predsMsk)
plot(futureProj)
```

```{asis, echo = mess}
### Calculate Environmental Similarity
To visualize the environmental difference between the occurrence localities and your selected projection extent, calculate a multidimensional environmental similarity surface (MESS). High negative values mean great difference, whereas high positive values mean great similarity. Interpreting the projected suitability for areas with high negative values should be done with extreme caution, as they are outside the environmental range of the occurrence localities.
```

```{r projMESS, echo = mess, eval = mess, include = mess}
# extract environmental values from occurrence localities -- these were the values that went into the model
occVals <- raster::extract(preds, occs.locs)
# compare these values with the projection extent (predsMsk)
occVals.mess <- dismo::mess(predsMsk, occVals)
plot(occVals.mess)
```
